"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_plugins_1 = require("@expo/config-plugins");
const generateCode_1 = require("@expo/config-plugins/build/utils/generateCode");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const PUBLIC_MODULE = 'react-native-background-geolocation';
const PRIVATE_MODULE = PUBLIC_MODULE + '-android';
const META_LICENSE_KEY = "com.transistorsoft.locationmanager.license";
const META_HMS_LICENSE_KEY = "com.transistorsoft.locationmanager.hms.license";
const META_POLYGON_LICENSE_KEY = "com.transistorsoft.locationmanager.polygon.license";
const findModuleRecursively = (dir) => {
    const nodeModules = path_1.default.resolve(dir, 'node_modules');
    if (fs_1.default.existsSync(path_1.default.join(nodeModules, PUBLIC_MODULE))) {
        return PUBLIC_MODULE;
    }
    if (fs_1.default.existsSync(path_1.default.join(nodeModules, PRIVATE_MODULE))) {
        return PRIVATE_MODULE;
    }
    const parent = path_1.default.resolve(dir, '..');
    if (parent === dir) {
        // we have reached the root of the file system -> not found
        return null;
    }
    return findModuleRecursively(parent);
};
const MODULE_NAME = findModuleRecursively(path_1.default.resolve('.'));
if (!MODULE_NAME) {
    console.error(`Could not find neither '${PUBLIC_MODULE}' or '${PRIVATE_MODULE}' in node_modules`);
    process.exit(1);
}
const { addMetaDataItemToMainApplication, removeMetaDataItemFromMainApplication, getMainApplicationOrThrow } = config_plugins_1.AndroidConfig.Manifest;
const androidPlugin = (config, props = {}) => {
    config = (0, config_plugins_1.withProjectBuildGradle)(config, ({ modResults, ...subConfig }) => {
        if (modResults.language !== 'groovy') {
            config_plugins_1.WarningAggregator.addWarningAndroid('withBackgroundGeolocation', `Cannot automatically configure project build.gradle if it's not groovy`);
            return { modResults, ...subConfig };
        }
        modResults.contents = applyMavenUrl(modResults.contents);
        return { modResults, ...subConfig };
    });
    config = (0, config_plugins_1.withAppBuildGradle)(config, ({ modResults, ...subConfig }) => {
        if (modResults.language !== 'groovy') {
            config_plugins_1.WarningAggregator.addWarningAndroid('withBackgroundGeolocation', `Cannot automatically configure project build.gradle if it's not groovy`);
            return { modResults, ...subConfig };
        }
        modResults.contents = applyAppGradle(modResults.contents);
        return { modResults, ...subConfig };
    });
    config = (0, config_plugins_1.withAndroidManifest)(config, async (config) => {
        console.log("[react-native-background-geolocation] Adding license-keys to AndroidManifest:", props);
        const mainApplication = getMainApplicationOrThrow(config.modResults);
        addMetaDataItemToMainApplication(mainApplication, META_LICENSE_KEY, props.license || "UNDEFINED");
        if (props.hmsLicense) {
            addMetaDataItemToMainApplication(mainApplication, META_HMS_LICENSE_KEY, props.hmsLicense);
        }
        else {
            removeMetaDataItemFromMainApplication(mainApplication, META_HMS_LICENSE_KEY);
        }
        if (props.polygonLicense) {
            addMetaDataItemToMainApplication(mainApplication, META_POLYGON_LICENSE_KEY, props.polygonLicense);
        }
        else {
            removeMetaDataItemFromMainApplication(mainApplication, META_POLYGON_LICENSE_KEY);
        }
        return config;
    });
    return config;
};
const applyAppGradle = (buildGradle) => {
    // Apply background-geolocation.gradle
    const newSrc = [];
    newSrc.push(`Project background_geolocation = project(':${MODULE_NAME}')`);
    newSrc.push(`apply from: "\${background_geolocation.projectDir}/app.gradle"`);
    buildGradle = (0, generateCode_1.mergeContents)({
        tag: `${MODULE_NAME}-project`,
        src: buildGradle,
        newSrc: newSrc.join("\n"),
        anchor: /android\s\{/,
        offset: 1,
        comment: "//",
    }).contents;
    return buildGradle;
};
/**
 * DISABLED in favour of gradle.properties
 *
const applyExtVars = (buildGradle: string, props:Props) => {

  const newSrc = [];

  const ext = props.ext;
  if (ext) {
    for (let [key, value] of ext) {
      if (typeof(value) === 'boolean') {
        newSrc.push(`\t${key} = ${value}`)
      } else {
        newSrc.push(`\t${key} = "${value}"`)
      }
    }
  }

  return mergeContents({
    tag: `${MODULE_NAME}-ext`,
    src: buildGradle,
    newSrc: newSrc.join("\n"),
    anchor: /ext(?:\s+)?\{/,
    offset: 1,
    comment: "//",
  }).contents;
}
*/
const applyMavenUrl = (buildGradle) => {
    return (0, generateCode_1.mergeContents)({
        tag: `${MODULE_NAME}-maven`,
        src: buildGradle,
        newSrc: `\tmaven { url "\${project(":${MODULE_NAME}").projectDir}/libs" }\n\tmaven { url 'https://developer.huawei.com/repo/' }`,
        anchor: /maven\s\{/,
        offset: 1,
        comment: "//",
    }).contents;
};
exports.default = androidPlugin;
//# sourceMappingURL=androidPlugin.js.map